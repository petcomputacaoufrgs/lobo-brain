Ideia de implementacao de grafo para a representacao do tabuleiro

* O que temos atualmente?
    A representacao do tabuleiro esta atualmente representaca na forma de array de char (vector<vector<char>>).
    NO entanto esta forma de representcao impede a criacao de um codigo generico para diversos tipos de tabuleiros
    para 'row games'. Dessa forma, a ideia eh mudar a forma de implementacao da classe Tabuleiro para um grafo, o que,
    portanto iria gerar, como consequencia, a modificacao de diversas funcoes e a reescritura das funcoes move.cpp
    e VDE.cpp, nas quais serao discutidas mais adiante.

* Discussao da tual implementacao das funcoes
    * tabuleiro.cpp
        Aqui deveremos mudar toda forma de implementacao. Pensando na implementacao de grafo, teremos quer ter os campos vertices e
        arestas a fim de podermos representar o grafo como uma lista de adjacencia.
        Teremos possivelmente os seguintes campos:

            vertice{
                int posicao; //posicao [0, x] dependendo do tabuleiro
                int player; // jogador que ocupa a posicao (1 - jogador 1, 2 - jogador 2, 0 - vazio)
            }

            vector<vector<int>> lista_adjacencia; // as posicoes [i, j] serao respectivamente a linha e a coluna do tabuleiro
            //sendo que i,j pertencem a [0, 3]

    * move.cpp
        Em move.cpp temos apenas uma funcao 'vector<vector<int>> tapatanMoves(int player_pos)', na qual o uso se torna
        restrita ao tabuleiro de Tapatan. A funcao recebe como entrada uma posicao atual do jogador no tabuleiro [0, 8]
        e nela verificamos as possiveois movimentacoes dependendo da posicao atual.
        A ideia é representar o tabuleiro como um grafo, ou seja, como uma lista de adjacencia, no caso, os vertices
        serao representados pelas posicoes do tabuleiro ([0, 8], no caso do Tapatan) e as arestas serao as ligacoes
        entre as posiceos (vertices) adjacentes. Cada vertice poderá ser representado da seguinte forma:

        vertice{
            int posicao; //posicao [0, x] dependendo do tabuleiro
            int player; // jogador que ocupa a posicao (1 - jogador 1, 2 - jogador 2, 0 - vazio)
        }

        Dessa forma, para verificar as possiveis moviementacoes basta verificar se há uma aresta entre dois vertices e
        se esse vertice adjacente esta vazio - player == 0 .

        No entanto, devemos verificar a melhor forma de retorno, dessa funcao. Podemos manter o retorno como um vector<vector<int>>
        que seria uma tupla de pares ordenados -  a posicao do tabuleiro.


    * node.cpp
        Em node.cpp o metodo contrutor recebe um rtabuleiro, dessa forma, basta mudar a estrutura do tabuleiro

    * tree.cpp
        Aqui esta a merda.

        Sabemos que na generateChildren chamamos a funcao generateBoards, que gera possiveis tabuleiros de acordo com o tabuleiro atual
        passado como entrada (Node* current_state que possui um atrubuto board, que guarda um tabuleiro, que no caso sera alterado para
        grafo), e a partir dai varremos todo o tabuleiro gerando as possiveis jogadas.
        Aqui deveremos alterar para trabalharmos com o tabuleiro na forma de um grafo.

    * VDE.cpp
        Aqui esta a merda ².
        Devera ser adaptada de acordo com a regra do jogo.

    * decision.cpp
        Nao precisara ser alterada.


* Esqueleto basico da classe Tabuleiro

class Tabuleiro
{
    public:
        Vertice casa_tabuleiro;

        Tabuleiro(Vertice* posicao); // o tabuleiro pode ser inicializado
        // a partir de um vertice inicial


}

class Vertice
{
    public:
        int posicao;
        int player;
        vector<Vertice*> vizinhos; // lista de adjacencia (cada vertice possui uma lista de vizinhos)

        Vertice(int pos, int player); // na inicializacao do tabuleiro
        // as casa nao ocupadas devem ser inicizalizadas com 0

        void addNeighbour(Vertice *newNeighbour);

}


Precisamos saber a posição do Ribas sobre:
    *  Quantos tipos de tabuleiros teremos


Da mudança para grafo:
    - Função para tradução de grafo para matriz de char, util apenas enquanto não temos parte gráfica
    - Lista de adjacência como descrita acima
    - Refazer as funções: Move(aparentemente será genérica para jogos de bloqueio e alinhamento), evaluations()
